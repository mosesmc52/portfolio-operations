# reporting/tasks.py
from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Dict

from celery import shared_task
from django.conf import settings
from django.db import transaction
from performance.models import MonthlySnapshot
from reporting.models import Report
from services.llm.chatgpt_reporting_service import (
    ChatGPTConfig,
    ChatGPTMonthlyReportingService,
)


def _reports_dir_for_snapshot(snapshot: MonthlySnapshot) -> Path:
    """
    Example path:
      MEDIA_ROOT/reports/account_<id>/2025-12/
    """
    ym = snapshot.as_of_month.strftime("%Y-%m")
    base = Path(settings.MEDIA_ROOT) / "reports" / f"account_{snapshot.account_id}" / ym
    base.mkdir(parents=True, exist_ok=True)
    return base


def _render_commentary_md(snapshot: MonthlySnapshot, c: Dict) -> str:
    # Deterministic Markdown renderer (keeps formatting consistent across months)
    perf = (snapshot.metrics_json or {}).get("performance", {})
    risk = (snapshot.metrics_json or {}).get("risk", {})
    activity = (snapshot.metrics_json or {}).get("activity", {})

    lines = []
    lines.append(f"# Monthly Commentary â€” {snapshot.as_of_month:%B %Y}")
    lines.append("")
    lines.append(f"**Strategy Version:** {snapshot.strategy_version}")
    lines.append("")

    lines.append("## Executive Summary")
    for b in c["executive_bullets"]:
        lines.append(f"- {b}")
    lines.append("")

    lines.append("## Performance")
    lines.append(c["performance_commentary"])
    lines.append("")

    lines.append("## Risk")
    lines.append(c["risk_commentary"])
    lines.append("")

    lines.append("## Positioning")
    lines.append(c["positioning_commentary"])
    lines.append("")

    lines.append("## Activity")
    lines.append(c["activity_commentary"])
    lines.append("")

    lines.append("## Model Notes")
    lines.append(c["model_notes"])
    lines.append("")

    lines.append("## Disclosures")
    for d in c["disclosures"]:
        lines.append(f"- {d}")
    lines.append("")

    return "\n".join(lines)


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 5},
)
def generate_monthly_commentary_report(self, snapshot_id: int) -> Dict:
    """
    Generates AI narrative + saves artifacts for a given MonthlySnapshot.

    Django-related actions (DB writes + filesystem writes) happen here.
    LLM call happens in services/ (no Django there).
    """
    snapshot = MonthlySnapshot.objects.select_related("account", "account__client").get(
        id=snapshot_id
    )

    if not snapshot.metrics_json:
        raise ValueError(
            "MonthlySnapshot.metrics_json is empty; compute metrics before running commentary agent."
        )

    # Config from Django settings
    cfg = ChatGPTConfig(
        api_key=getattr(settings, "OPENAI_API_KEY"),
        model=getattr(settings, "OPENAI_MODEL", "gpt-5.2"),
        temperature=float(getattr(settings, "OPENAI_TEMPERATURE", 0.2)),
    )
    svc = ChatGPTMonthlyReportingService(cfg)

    # Call LLM via service
    out = svc.generate_monthly_commentary(snapshot.metrics_json)
    commentary = out["commentary"]

    # Force disclosures to your fixed list (deterministic + compliance hygiene)
    commentary["disclosures"] = svc.DISCLOSURES

    # Write files
    out_dir = _reports_dir_for_snapshot(snapshot)
    json_path = out_dir / "commentary.json"
    md_path = out_dir / "commentary.md"

    json_path.write_text(
        json.dumps(commentary, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    md_path.write_text(_render_commentary_md(snapshot, commentary), encoding="utf-8")

    # Upsert Report row
    # Your Report model currently requires tearsheet_pdf_path.
    # If your tear sheet is generated by a separate task, set a placeholder here and overwrite later.
    placeholder_tearsheet = str(out_dir / "tearsheet_PENDING.pdf")

    with transaction.atomic():
        report, created = Report.objects.update_or_create(
            snapshot=snapshot,
            defaults={
                "tearsheet_pdf_path": placeholder_tearsheet,
                "commentary_md_path": str(md_path),
                "commentary_pdf_path": None,
                "llm_model": out["llm_model"],
                "prompt_hash": out["prompt_hash"],
                "inputs_hash": out["inputs_hash"],
            },
        )

    return {
        "snapshot_id": snapshot_id,
        "report_id": report.id,
        "commentary_json_path": str(json_path),
        "commentary_md_path": str(md_path),
        "tearsheet_pdf_path": report.tearsheet_pdf_path,
        "llm_model": out["llm_model"],
        "created": created,
    }


@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 5},
)
def render_commentary_pdf(self, snapshot_id: int) -> dict:
    """
    Convert the saved commentary.md to PDF and update Report.commentary_pdf_path.
    """
    import markdown as md
    from weasyprint import CSS, HTML

    snapshot = MonthlySnapshot.objects.get(id=snapshot_id)
    report = Report.objects.get(snapshot=snapshot)

    md_path = Path(report.commentary_md_path)
    if not md_path.exists():
        raise FileNotFoundError(f"commentary_md_path not found: {md_path}")

    out_dir = md_path.parent
    pdf_path = out_dir / "commentary.pdf"

    # Markdown -> HTML
    md_text = md_path.read_text(encoding="utf-8")
    html_body = md.markdown(md_text, extensions=["tables", "fenced_code"])

    # Basic HTML wrapper + CSS (you can improve later)
    html = f"""
    <html>
      <head>
        <meta charset="utf-8">
        <style>
          body {{ font-family: Arial, sans-serif; font-size: 12pt; color: #1B3C53; }}
          h1 {{ font-size: 20pt; margin-bottom: 0.2in; }}
          h2 {{ font-size: 14pt; margin-top: 0.25in; }}
          ul {{ margin: 0.1in 0 0.2in 0.2in; }}
          li {{ margin: 0.05in 0; }}
          code, pre {{ font-family: Menlo, monospace; font-size: 10pt; }}
          pre {{ background: #E3E3E3; padding: 8px; border-radius: 6px; }}
        </style>
      </head>
      <body>
        {html_body}
      </body>
    </html>
    """

    # Render HTML -> PDF
    HTML(string=html).write_pdf(str(pdf_path))

    # Update DB
    with transaction.atomic():
        report.commentary_pdf_path = str(pdf_path)
        report.save(update_fields=["commentary_pdf_path"])

    return {"snapshot_id": snapshot_id, "commentary_pdf_path": str(pdf_path)}
